# =============================================================================
# Animation Audio Sync System
# Frame-accurate sound triggers for AAA combat feel
# Generated by VEILBREAKERS Animation MCP
# =============================================================================

class_name AnimationAudioSync
extends Node

# -----------------------------------------------------------------------------
# SIGNALS
# -----------------------------------------------------------------------------
signal sound_triggered(sound_id: String, position: Vector2)

# -----------------------------------------------------------------------------
# AUDIO BUS CONFIGURATION
# -----------------------------------------------------------------------------
const BUS_SFX = "SFX"
const BUS_VOICE = "Voice"
const BUS_IMPACT = "Impact"  # Separate bus for hit sounds (easy to punch up)
const BUS_AMBIENT = "Ambient"

# -----------------------------------------------------------------------------
# SOUND DATA
# -----------------------------------------------------------------------------
# Sound definitions with variations
const SOUNDS: Dictionary = {
	# Combat - Attacks
	"attack_whoosh_light": {
		"paths": [
			"res://audio/sfx/combat/whoosh_light_01.ogg",
			"res://audio/sfx/combat/whoosh_light_02.ogg",
			"res://audio/sfx/combat/whoosh_light_03.ogg",
		],
		"bus": "SFX",
		"volume_range": Vector2(-3, 0),
		"pitch_range": Vector2(0.95, 1.05),
	},
	"attack_whoosh_heavy": {
		"paths": [
			"res://audio/sfx/combat/whoosh_heavy_01.ogg",
			"res://audio/sfx/combat/whoosh_heavy_02.ogg",
		],
		"bus": "SFX",
		"volume_range": Vector2(-2, 2),
		"pitch_range": Vector2(0.9, 1.0),
	},
	
	# Combat - Impacts (by brand)
	"hit_savage": {
		"paths": [
			"res://audio/sfx/combat/hit_flesh_01.ogg",
			"res://audio/sfx/combat/hit_flesh_02.ogg",
			"res://audio/sfx/combat/hit_flesh_03.ogg",
		],
		"bus": "Impact",
		"volume_range": Vector2(0, 3),
		"pitch_range": Vector2(0.9, 1.1),
	},
	"hit_iron": {
		"paths": [
			"res://audio/sfx/combat/hit_metal_01.ogg",
			"res://audio/sfx/combat/hit_metal_02.ogg",
		],
		"bus": "Impact",
		"volume_range": Vector2(0, 3),
		"pitch_range": Vector2(0.85, 1.0),
	},
	"hit_venom": {
		"paths": [
			"res://audio/sfx/combat/hit_acid_01.ogg",
			"res://audio/sfx/combat/hit_acid_02.ogg",
		],
		"bus": "Impact",
		"volume_range": Vector2(-2, 2),
		"pitch_range": Vector2(0.9, 1.1),
	},
	"hit_surge": {
		"paths": [
			"res://audio/sfx/combat/hit_electric_01.ogg",
			"res://audio/sfx/combat/hit_electric_02.ogg",
		],
		"bus": "Impact",
		"volume_range": Vector2(0, 3),
		"pitch_range": Vector2(1.0, 1.2),
	},
	"hit_dread": {
		"paths": [
			"res://audio/sfx/combat/hit_dark_01.ogg",
			"res://audio/sfx/combat/hit_dark_02.ogg",
		],
		"bus": "Impact",
		"volume_range": Vector2(-3, 0),
		"pitch_range": Vector2(0.7, 0.9),
	},
	"hit_leech": {
		"paths": [
			"res://audio/sfx/combat/hit_drain_01.ogg",
			"res://audio/sfx/combat/hit_drain_02.ogg",
		],
		"bus": "Impact",
		"volume_range": Vector2(-2, 2),
		"pitch_range": Vector2(0.9, 1.05),
	},
	"hit_critical": {
		"paths": [
			"res://audio/sfx/combat/hit_crit_01.ogg",
			"res://audio/sfx/combat/hit_crit_02.ogg",
		],
		"bus": "Impact",
		"volume_range": Vector2(2, 5),
		"pitch_range": Vector2(0.95, 1.05),
	},
	
	# Combat - Reactions
	"hurt_grunt": {
		"paths": [
			"res://audio/sfx/voice/grunt_hurt_01.ogg",
			"res://audio/sfx/voice/grunt_hurt_02.ogg",
			"res://audio/sfx/voice/grunt_hurt_03.ogg",
		],
		"bus": "Voice",
		"volume_range": Vector2(-5, 0),
		"pitch_range": Vector2(0.9, 1.1),
	},
	"death_cry": {
		"paths": [
			"res://audio/sfx/voice/death_cry_01.ogg",
			"res://audio/sfx/voice/death_cry_02.ogg",
		],
		"bus": "Voice",
		"volume_range": Vector2(0, 3),
		"pitch_range": Vector2(0.85, 1.0),
	},
	
	# Combat - Movement
	"footstep": {
		"paths": [
			"res://audio/sfx/movement/footstep_01.ogg",
			"res://audio/sfx/movement/footstep_02.ogg",
			"res://audio/sfx/movement/footstep_03.ogg",
			"res://audio/sfx/movement/footstep_04.ogg",
		],
		"bus": "SFX",
		"volume_range": Vector2(-10, -5),
		"pitch_range": Vector2(0.9, 1.1),
	},
	"dodge_roll": {
		"paths": [
			"res://audio/sfx/movement/roll_01.ogg",
			"res://audio/sfx/movement/roll_02.ogg",
		],
		"bus": "SFX",
		"volume_range": Vector2(-5, 0),
		"pitch_range": Vector2(0.95, 1.05),
	},
	
	# Effects
	"status_poison": {
		"paths": ["res://audio/sfx/status/poison_apply.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(-3, 0),
		"pitch_range": Vector2(1.0, 1.0),
	},
	"status_burn": {
		"paths": ["res://audio/sfx/status/burn_apply.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(-3, 0),
		"pitch_range": Vector2(1.0, 1.0),
	},
	"heal": {
		"paths": ["res://audio/sfx/effects/heal_01.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(0, 3),
		"pitch_range": Vector2(1.0, 1.1),
	},
	
	# UI
	"ui_select": {
		"paths": ["res://audio/sfx/ui/select.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(-5, -5),
		"pitch_range": Vector2(1.0, 1.0),
	},
	"ui_confirm": {
		"paths": ["res://audio/sfx/ui/confirm.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(-3, -3),
		"pitch_range": Vector2(1.0, 1.0),
	},
	"ui_cancel": {
		"paths": ["res://audio/sfx/ui/cancel.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(-5, -5),
		"pitch_range": Vector2(1.0, 1.0),
	},
	
	# Capture
	"capture_throw": {
		"paths": ["res://audio/sfx/capture/throw.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(0, 3),
		"pitch_range": Vector2(0.95, 1.05),
	},
	"capture_struggle": {
		"paths": ["res://audio/sfx/capture/struggle_01.ogg", "res://audio/sfx/capture/struggle_02.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(-3, 0),
		"pitch_range": Vector2(0.9, 1.1),
	},
	"capture_success": {
		"paths": ["res://audio/sfx/capture/success.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(0, 3),
		"pitch_range": Vector2(1.0, 1.0),
	},
	"capture_fail": {
		"paths": ["res://audio/sfx/capture/fail.ogg"],
		"bus": "SFX",
		"volume_range": Vector2(0, 2),
		"pitch_range": Vector2(0.95, 1.0),
	},
}

# Animation-to-sound mappings (frame triggers)
const ANIMATION_SOUNDS: Dictionary = {
	# Format: "animation_name": [{frame: int, sound: String, positional: bool}]
	"attack_anticipate": [
		{"frame": 2, "sound": "attack_whoosh_light", "positional": true},
	],
	"attack_strike": [
		{"frame": 1, "sound": "attack_whoosh_heavy", "positional": true},
	],
	"attack_heavy_anticipate": [
		{"frame": 3, "sound": "attack_whoosh_heavy", "positional": true},
	],
	"hurt_light": [
		{"frame": 0, "sound": "hurt_grunt", "positional": true},
	],
	"hurt_heavy": [
		{"frame": 0, "sound": "hurt_grunt", "positional": true},
	],
	"death_fall": [
		{"frame": 0, "sound": "death_cry", "positional": true},
		{"frame": 5, "sound": "hit_savage", "positional": true},  # Body impact
	],
	"walk": [
		{"frame": 1, "sound": "footstep", "positional": true},
		{"frame": 5, "sound": "footstep", "positional": true},
	],
	"run": [
		{"frame": 1, "sound": "footstep", "positional": true},
		{"frame": 4, "sound": "footstep", "positional": true},
	],
	"dodge": [
		{"frame": 0, "sound": "dodge_roll", "positional": true},
	],
	"capture_react": [
		{"frame": 0, "sound": "capture_throw", "positional": false},
	],
	"capture_struggle": [
		{"frame": 2, "sound": "capture_struggle", "positional": true},
	],
	"capture_success": [
		{"frame": 4, "sound": "capture_success", "positional": false},
	],
	"capture_break": [
		{"frame": 2, "sound": "capture_fail", "positional": true},
	],
}

# -----------------------------------------------------------------------------
# EXPORTS
# -----------------------------------------------------------------------------
@export_group("Configuration")
@export var max_simultaneous_sounds: int = 16
@export var positional_audio_range: float = 500.0
@export var enable_variations: bool = true

@export_group("Node References")
@export var listener_node: Node2D  # Usually the player or camera

# -----------------------------------------------------------------------------
# STATE
# -----------------------------------------------------------------------------
var _audio_pool: Array[AudioStreamPlayer] = []
var _positional_pool: Array[AudioStreamPlayer2D] = []
var _loaded_sounds: Dictionary = {}  # path -> AudioStream
var _last_variation: Dictionary = {}  # sound_id -> last_index (prevent repeats)

# -----------------------------------------------------------------------------
# LIFECYCLE
# -----------------------------------------------------------------------------
func _ready() -> void:
	_initialize_audio_pools()
	_preload_sounds()

func _initialize_audio_pools() -> void:
	# Non-positional pool
	for i in range(max_simultaneous_sounds / 2):
		var player = AudioStreamPlayer.new()
		add_child(player)
		_audio_pool.append(player)
	
	# Positional pool
	for i in range(max_simultaneous_sounds / 2):
		var player = AudioStreamPlayer2D.new()
		player.max_distance = positional_audio_range
		add_child(player)
		_positional_pool.append(player)

func _preload_sounds() -> void:
	for sound_id in SOUNDS:
		var sound_data = SOUNDS[sound_id]
		for path in sound_data.paths:
			if not _loaded_sounds.has(path):
				var stream = load(path)
				if stream:
					_loaded_sounds[path] = stream

# -----------------------------------------------------------------------------
# PUBLIC API
# -----------------------------------------------------------------------------
func play_sound(sound_id: String, position: Vector2 = Vector2.ZERO, positional: bool = false) -> void:
	"""Play a sound by ID with optional position"""
	if not SOUNDS.has(sound_id):
		push_warning("AnimationAudioSync: Unknown sound: " + sound_id)
		return
	
	var sound_data = SOUNDS[sound_id]
	var stream = _get_variation(sound_id, sound_data)
	if not stream:
		return
	
	var player = _get_available_player(positional)
	if not player:
		return
	
	player.stream = stream
	player.bus = sound_data.get("bus", "SFX")
	
	# Random volume
	var vol_range = sound_data.get("volume_range", Vector2(0, 0))
	player.volume_db = randf_range(vol_range.x, vol_range.y)
	
	# Random pitch
	var pitch_range = sound_data.get("pitch_range", Vector2(1, 1))
	player.pitch_scale = randf_range(pitch_range.x, pitch_range.y)
	
	# Position for 2D audio
	if positional and player is AudioStreamPlayer2D:
		player.global_position = position
	
	player.play()
	sound_triggered.emit(sound_id, position)

func play_hit_sound(brand: String, is_critical: bool = false, position: Vector2 = Vector2.ZERO) -> void:
	"""Play appropriate hit sound for brand"""
	if is_critical:
		play_sound("hit_critical", position, true)
	else:
		var sound_id = "hit_" + brand.to_lower()
		if SOUNDS.has(sound_id):
			play_sound(sound_id, position, true)
		else:
			play_sound("hit_savage", position, true)  # Fallback

func play_animation_sounds(animation_name: String, current_frame: int, position: Vector2) -> void:
	"""Check and play any sounds for current animation frame"""
	if not ANIMATION_SOUNDS.has(animation_name):
		return
	
	for trigger in ANIMATION_SOUNDS[animation_name]:
		if trigger.frame == current_frame:
			play_sound(trigger.sound, position, trigger.get("positional", true))

# -----------------------------------------------------------------------------
# INTERNAL
# -----------------------------------------------------------------------------
func _get_variation(sound_id: String, sound_data: Dictionary) -> AudioStream:
	var paths: Array = sound_data.paths
	if paths.is_empty():
		return null
	
	if not enable_variations or paths.size() == 1:
		return _loaded_sounds.get(paths[0])
	
	# Avoid repeating same variation
	var last_idx = _last_variation.get(sound_id, -1)
	var idx = randi() % paths.size()
	
	if paths.size() > 1:
		while idx == last_idx:
			idx = randi() % paths.size()
	
	_last_variation[sound_id] = idx
	return _loaded_sounds.get(paths[idx])

func _get_available_player(positional: bool) -> Node:
	var pool = _positional_pool if positional else _audio_pool
	
	for player in pool:
		if not player.playing:
			return player
	
	# All busy - steal oldest
	return pool[0]

# -----------------------------------------------------------------------------
# ANIMATION CONTROLLER INTEGRATION
# -----------------------------------------------------------------------------
func connect_to_animation_controller(controller: Node) -> void:
	"""Connect this audio system to an animation controller"""
	if controller.has_signal("animation_event"):
		controller.animation_event.connect(_on_animation_event)

func _on_animation_event(event_name: String, data: Dictionary) -> void:
	match event_name:
		"play_sound":
			var sound_id = data.get("sound", "")
			var position = data.get("position", Vector2.ZERO)
			play_sound(sound_id, position, true)
		
		"spawn_hit_effect":
			# Audio for hit effect
			var brand = data.get("brand", "SAVAGE")
			var position = data.get("position", Vector2.ZERO)
			play_hit_sound(brand, false, position)
